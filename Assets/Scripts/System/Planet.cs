//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System.Collections.Generic;

public class Planet : CBody
{
    public const float SIZE_ROCKY_MEAN = 5500f;
    public const float SIZE_ROCKY_STD_DEV = 1750f;
    public const float SIZE_ROCKY_BOUND = 4000f;
	const float SIZE_GAS_MEAN = 50000f;
	const float SIZE_GAS_STD_DEV = 14000f;
	const float SIZE_GAS_BOUND = 35000f;
    public const float HAB_NOT_TER = 6f;
    public const float HAB_LOW_BOUND = 5.9f;
    public const float HAB_HIGH_BOUND = 12f;
    public const float HAB_CONCENTRATION = 1.5f;


	public bool rocky;
	public bool terrestrial;
	protected string spriteName;
    public float habitability;
    public float mineralAbundance;
    public float gasAbundance;
    public float desirability;

    public Colony colony;
    private const float DESIRABILITY_EASING = 2600000f;

    public float carryingCapacity
    {
        get { return Mathf.Pow(10, habitability); }
    }

	public Planet(Star parent, StarSystem system) : base(0,0,0,0,parent,system) {
        rocky = Random.value < .5f;
        float r = rocky ? Random.Range(2.470f, 6.782f) : Random.Range(2.646f, 6.782f);
		aphelion = Mathf.Pow(parent.solarMass, 1/3f) * (r * r - 6);
        angle = Random.Range(0f, 2 * Mathf.PI);
		size=rocky ? BellCurve.random(SIZE_ROCKY_MEAN, SIZE_ROCKY_STD_DEV, SIZE_ROCKY_BOUND)
			: BellCurve.random(SIZE_GAS_MEAN,SIZE_GAS_STD_DEV,SIZE_GAS_BOUND);
		density=rocky ? Random.Range(3f,6f) 
			: Random.Range(.5f,2f);
        rollHabitability();
        mineralAbundance = rocky ? Random.value : 0;
        gasAbundance = rocky ? 0 : Random.value;
        desirability = baseDesirability();
        colony = null;
        //debug Earth data
		/*rocky = terrestrial = true;
		aphelion = 1f;
		angle = 0f;
		size = 6370f;
		density = 5.514f;*/
		
        rollMoons(rocky);
	}

    public void rollHabitability()
    {
        Planet planet = (Planet)(parent is Planet ? parent : this);
        if (rocky)
        {
            float x = HAB_CONCENTRATION * Mathf.Log(planet.aphelion / ((Star)planet.parent).goldilocksCenter);
            habitability = (HAB_HIGH_BOUND - HAB_LOW_BOUND) * Mathf.Exp(-x * x) * Random.value + HAB_LOW_BOUND;
            terrestrial = habitability > HAB_NOT_TER;
            if (!terrestrial)
            {
                habitability = HAB_NOT_TER;
            }
        }
        else
        {
            habitability = HAB_NOT_TER;
        }
        genSpriteName();
    }


    //Moon chance is connected to size so that larger rockies get more moons.
    public void rollMoons(bool rocky)
    {
        children.Clear();
        float moonChance = rocky ? (size / (5 * SIZE_ROCKY_MEAN)) : 2f / 5f;
        for (int i = 0; i < 10 && Random.value < moonChance; i++)
        {
            for (int retries = 0; retries < 15; retries++)
            {
                Moon moon = new Moon(this, system);
                if (StarSystem.hillSphereCheck(moon, children, mass))
                {
                    children.Add(moon);
                    break;
                }
            }
        }
    }

    
    public float baseDesirability()
    {
        return Mathf.Exp(habitability*(mineralAbundance+1));
    }

    public float desirabilityFor(Empire e)
    {
        return desirability * (colony == null ? 1 : e.settings.colonizationPenalty*(e.colonies.Count+5));
    }

	public Planet(CBody parent, StarSystem system) : base(0,0,0,0,parent,system) {}

	public override string getPlanetSprite() {
		return spriteName;
	}

	public void genSpriteName()
	{
		string s;
		if (rocky)
		{
			if (size < 4250f)
			{
				s = "3";
			}
			else if (size > 7000f)
			{
				s = "1";
			}
			else
			{
				s = "2";
			}
			if (terrestrial)
			{
				s += "ter";
			}
		}
		else
		{
			if (size < 38000f)
			{
				s = "3";
			}
			else if (size > 62000f)
			{
				s = "1";
			}
			else
			{
				s = "2";
			}
			float ringChance = Random.value;
			if (ringChance > .6)
			{
                spriteName = "gasgiant" + s + (ringChance > .8 ? "ring2": "ring1");
                return;
			}
		}
        spriteName = (rocky ? "planet" : "gasgiant") + s;
	}

    public override void tick(int deltaTime)
    {
        base.tick(deltaTime);
        if(colony!=null)
        {
            float goalDesirability = Mathf.Exp(-colony.population / carryingCapacity)*baseDesirability();
            desirability += (goalDesirability - desirability) * deltaTime/DESIRABILITY_EASING;
        }
        if (colony != null)
        {
            colony.tick(deltaTime);
        }
    }
}

public class Moon : Planet
{
	
	public Moon(Planet parent, StarSystem system) : base(parent,system) {
		rocky = true;
        Star star = (Star)parent.parent;
		float parentHillSphere = parent.hillSphere(star.mass);
		aphelion=Random.Range(parentHillSphere/20,parentHillSphere/5);
		angle=Random.Range(0f,2*Mathf.PI);
		size=parent.rocky ? BellCurve.random(SIZE_ROCKY_MEAN,SIZE_ROCKY_STD_DEV,SIZE_ROCKY_BOUND)/3 
			: BellCurve.random(SIZE_ROCKY_MEAN, SIZE_ROCKY_STD_DEV, SIZE_ROCKY_BOUND);
		density=Random.Range(3f,6f);
        rollHabitability();
    }
}

